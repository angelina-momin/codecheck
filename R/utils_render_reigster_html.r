#' Function for adding repository links in the register table for the creation of the html file.
#' 
#' @param register_table The register table
#' @return Register table with adjusted repository links
add_repository_links_html <- function(register_table) {
  register_table$Repository <- sapply(
    X = register_table$Repository,
    FUN = function(repository) {
      spec <- parse_repository_spec(repository)
      if (!any(is.na(spec))) {
        urrl <- "#"
        if (spec[["type"]] == "github") {
          urrl <- paste0("https://github.com/", spec[["repo"]])
          paste0("<i class='fa fa-github'></i>&nbsp;[", spec[["repo"]], "](", urrl, ")")
        } else if (spec[["type"]] == "osf") {
          urrl <- paste0("https://osf.io/", spec[["repo"]])
          paste0("<i class='ai ai-osf'></i>&nbsp;[", spec[["repo"]], "](", urrl, ")")
        } else if (spec[["type"]] == "gitlab") {
          urrl <- paste0("https://gitlab.com/", spec[["repo"]])
          paste0("<i class='fa fa-gitlab'></i>&nbsp;[", spec[["repo"]], "](", urrl, ")")
        } else {
          repository
        }
      } else {
        repository
      }
    }
  )
  return(register_table)
}

#' Dynamically generates a html_document.yml with the full paths to the index header, prefix 
#' and postfix.html files. 
#' 
#' @return None
generate_html_document_yml <- function(filter, register_table_name) {
  dir <- paste0(getwd(), get_output_dir(filter, register_table_name))

  yaml_content <- sprintf(
    "# DO NOT EDIT THIS FILE MANUALLY
    html_document:
      includes:
        in_header: '%sindex_header.html'
        before_body: '%sindex_prefix.html'
        after_body: '%sindex_postfix.html'
      mathjax: null
      highlight: null
      self_contained: false
      lib_dir: libs",
    dir, dir, dir
  )
  writeLines(yaml_content, paste0(dir, "html_document.yml"))
}

create_index_postfix_html <- function(filter, register_table_name){
  hrefs <- set_html_postfix_hrefs(filter, register_table_name)

  # Using the index_postfix_template
  postfix_template <- readLines(paste0(getwd(), "/docs/index_postfix.html"), warn = FALSE)

  # Render the template with the correct hrefs
  output <- whisker.render(postfix_template, hrefs)
  writeLines(output, get_output_dir(filter, register_table_name))
}

create_index_prefix_html <- function(filter, register_table_name){
  # Using the index_prefix_template
  prefix_template <- readLines(paste0(getwd(), "/docs/index_prefix.html"), warn = FALSE)

  writeLines(prefix_template, get_output_dir(filter, register_table_name))
}

create_index_header_html <- function(filter, register_table_name){
  # Using the index_header_template
  header_template <- readLines(paste0(getwd(), "/docs/index_header.html"), warn = FALSE)

  writeLines(header_template, get_output_dir(filter, register_table_name))
}

set_html_postfix_hrefs <- function(filter, register_table_name) {
  hrefs <- list(
    csv_source_href = set_href(filter, register_table_name, "csv_source"),
    searchable_csv_href = set_href(filter, register_table_name, "searchable_csv"),
    json_href = set_href(filter, register_table_name, "json"),
    md_href = set_href(filter, register_table_name, "md")
  )
  return(hrefs)
}

set_href <- function(filter, register_table_name, href_type) {
  base_url <- "https://"
  
  # Determine base path based on the resource type
  switch(href_type,
         "csv_source" = base_url <- paste0(base_url, "raw.githubusercontent.com/codecheckers/register/master/"),
         "searchable_csv" = base_url <- paste0(base_url, "github.com/codecheckers/register/blob/master/"),
         "json" = base_url <- paste0(base_url, "codecheck.org.uk/register/"),
         "md" = base_url <- paste0(base_url, "codecheck.org.uk/register/")
        )
  
  if (filter == "None") {
    return(paste0(base_url, "register.", href_type))
  } else if (filter == "venue") {
    venue_category <- determine_venue_category(register_table_name)
    venue_name <- trimws(gsub("[()]", "", gsub(venue_category, "", register_table_name)))
    return(paste0(base_url, filter, "/", venue_category, "/", venue_name, "/register.", href_type))
  } else {
    return(paste0(base_url, filter, "/", register_table_name, "/register.", href_type))
  }
}

create_section_htmls <- function(filter, register_table_name) {
  create_index_postfix_html(filter, register_table_name)
  create_index_prefix_html(filter, register_table_name)
  create_index_header_html(filter, register_table_name)
}

render_register_html <- function(filter, register_table, register_table_name, md_table, md_columns_widths){
  generate_html_document_yml(filter, register_table_name)
  
  # Add icons to the Repository column for HTML output, use a copy of the register.md
  register_table <- add_repository_links_html(register_table)

  # Dynamically create the index header, prefix and postfix files
  create_section_htmls(filter, register_table_name)
  create_html_yaml(filter, register_table_name)

  output_dir <- get_output_dir(filter, register_table_name)
  # Capture the HTML output from a markdown file
  # Check if .md already exists
  if (!dir.exists(paste0(output_dir, "register.md"))){
    md_file_path <- paste0(output_dir, "register.md")
    temp_md_used <- FALSE
  }

  # If .md does not exist create a temp md file
  else{
    render_register_md(filter, register_table, register_table_name, md_table, md_columns_widths, is_temp_file=TRUE)
    md_file_path <- paste0(output_dir, "temp.md")
    temp_md_used <- TRUE
  }

  yaml_path <- normalizePath(file.path(getwd(), paste0(output_dir, "docs/html_document.yml")))

  # Render HTML from markdown
  rmarkdown::render(
    input = md_file_path,
    output_file = "index.html",
    output_dir = output_dir,
    output_yaml = yaml_path
  )

  if (temp_md_used){
    file.remove(temp_file_path)
  }
}

render_register_htmls <- function(list_register_tables, md_template, md_columns_widths) {
  md_table <- load_md_template(md_template)

  # Loop over each register table
  for (filter in names(list_register_tables)){
    for (register_table_name in names(list_register_tables[[filter]])) {
      register_table <- list_register_tables[[filter]][[register_table_name]]
      render_register_html(filter, register_table, register_table_name, md_table, md_columns_widths)
    }
  }
}
